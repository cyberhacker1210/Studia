================================================================================
EXPORT WORKSPACE - FICHIERS BACKEND/FRONTEND
================================================================================

üìÇ STRUCTURE DES FICHIERS S√âLECTIONN√âS:
--------------------------------------------------------------------------------
  package.json
  requirements.txt
  src/studia/main.py
  src/studia/settings.py
  src/__init__.py
  src/studia/__init__.py
  src/studia/flashcard_generator.py
  src/studia/quiz_generator.py
  src/toto.py
  src/studia/quiz.json
  src/studia/quiz_ses.md
  app/api/waitlist/route.ts
  app/layout.tsx
  app/page.tsx
  app/sign-in/[[...sign-in]]/page.tsx
  app/sign-up/[[...sign-up]]/page.tsx
  app/workspace/capture/page.tsx
  app/workspace/courses/[id]/generate-flashcards/page.tsx
  app/workspace/courses/[id]/generate-quiz/page.tsx
  app/workspace/courses/[id]/page.tsx

Total: 20 fichiers

================================================================================
üìÑ CONTENU DES FICHIERS
================================================================================


////////////////////////////////////////////////////////////////////////////////
FICHIER: package.json
////////////////////////////////////////////////////////////////////////////////
{
  "devDependencies": {
    "@types/serviceworker": "^0.0.167"
  },
  "dependencies": {
    "canvas": "^3.2.0"
  }
}



////////////////////////////////////////////////////////////////////////////////
FICHIER: requirements.txt
////////////////////////////////////////////////////////////////////////////////
fastapi==0.109.0
uvicorn[standard]==0.27.0
python-dotenv==1.0.1
openai==1.12.0
pydantic==2.6.0
httpx==0.26.0


////////////////////////////////////////////////////////////////////////////////
FICHIER: src/studia/main.py
////////////////////////////////////////////////////////////////////////////////
"""
Studia API - FastAPI Application
"""
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Literal, List
from datetime import datetime
import uuid
import traceback

from .quiz_generator import quiz_generator_from_image, quiz_generator_from_text
from .flashcard_generator import generate_flashcards

app = FastAPI(
    title="Studia API",
    description="AI-powered learning platform",
    version="1.0.0"
)

# ============================================
# CORS
# ============================================
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ============================================
# MODELS
# ============================================

class QuizGenerateRequest(BaseModel):
    image: str
    num_questions: int = 5
    difficulty: Literal["easy", "medium", "hard"] = "medium"


class QuizGenerateFromTextRequest(BaseModel):
    course_text: str
    num_questions: int = 5
    difficulty: Literal["easy", "medium", "hard"] = "medium"


class FlashcardGenerateRequest(BaseModel):
    course_text: str
    num_cards: int = 10
    difficulty: Literal["easy", "medium", "hard"] = "medium"


class QuizQuestion(BaseModel):
    id: int
    question: str
    options: List[str]
    correctAnswer: int
    explanation: str


class Flashcard(BaseModel):
    front: str
    back: str
    category: str
    difficulty: str


class QuizResponse(BaseModel):
    id: str
    source: str
    difficulty: str
    questions: List[QuizQuestion]
    createdAt: str
    extractedText: str


class FlashcardResponse(BaseModel):
    id: str
    flashcards: List[Flashcard]
    createdAt: str


# ============================================
# HELPERS
# ============================================

def extract_base64_from_data_uri(data_uri: str) -> str:
    """Extract base64 data from data URI"""
    if "base64," in data_uri:
        return data_uri.split("base64,")[1]
    return data_uri


# ============================================
# ENDPOINTS
# ============================================

@app.get("/")
def root():
    return {
        "message": "Studia API - AI-powered learning platform üì∏",
        "version": "1.0.0",
        "status": "running",
        "endpoints": [
            "/api/health",
            "/api/quiz/generate-from-image",
            "/api/quiz/generate-from-text",
            "/api/flashcards/generate"
        ]
    }


@app.get("/api/health")
def health():
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat()
    }


@app.post("/api/quiz/generate-from-image", response_model=QuizResponse)
async def generate_quiz_from_image_endpoint(request: QuizGenerateRequest):
    """Generate quiz from course image with self-refining"""
    try:
        print("=" * 60)
        print(f"üì∏ NEW QUIZ REQUEST (FROM IMAGE)")
        print(f"   Questions: {request.num_questions}")
        print(f"   Difficulty: {request.difficulty}")

        # Extract base64
        image_base64 = extract_base64_from_data_uri(request.image)
        image_size_mb = (len(image_base64) * 3 / 4) / (1024 * 1024)
        print(f"   Image size: {image_size_mb:.2f}MB")

        if image_size_mb > 10:
            raise HTTPException(status_code=400, detail="Image trop grande (max 10MB)")

        # ‚úÖ Generate quiz with self-refining
        quiz_data = quiz_generator_from_image(
            image_base64=image_base64,
            num_questions=request.num_questions,
            difficulty=request.difficulty,
            enable_refinement=True  # Self-refining activ√©
        )

        # Format response
        quiz_id = str(uuid.uuid4())
        questions = []

        for i, q in enumerate(quiz_data["questions"]):
            questions.append(QuizQuestion(
                id=i + 1,
                question=q["question"],
                options=q["options"][:4],
                correctAnswer=q["correctAnswer"],
                explanation=q.get("explanation", "")
            ))

        response = QuizResponse(
            id=quiz_id,
            source="image",
            difficulty=request.difficulty,
            questions=questions,
            createdAt=datetime.now().isoformat(),
            extractedText=quiz_data.get("extractedText", "")
        )

        print(f"‚úÖ SUCCESS: {len(questions)} questions + {len(quiz_data.get('extractedText', ''))} chars extracted")
        if "metadata" in quiz_data:
            print(f"   üìä Metadata:")
            print(f"      Text confidence: {quiz_data['metadata'].get('extraction', {}).get('confidence_score', 'N/A')}%")
            print(f"      Quiz quality: {quiz_data['metadata'].get('quiz_quality', {}).get('final_score', 'N/A')}%")
        print("=" * 60)

        return response

    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå ERROR: {str(e)}")
        traceback.print_exc()
        print("=" * 60)
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/quiz/generate-from-text", response_model=QuizResponse)
async def generate_quiz_from_text_endpoint(request: QuizGenerateFromTextRequest):
    """Generate quiz from course text with self-refining"""
    try:
        print("=" * 60)
        print(f"üìù NEW QUIZ REQUEST (FROM TEXT)")
        print(f"   Questions: {request.num_questions}")
        print(f"   Difficulty: {request.difficulty}")
        print(f"   Text length: {len(request.course_text)} chars")

        if not request.course_text or len(request.course_text.strip()) < 10:
            raise HTTPException(
                status_code=400,
                detail="Le texte du cours est trop court ou vide"
            )

        # ‚úÖ Generate quiz with self-refining
        quiz_data = quiz_generator_from_text(
            course_text=request.course_text,
            num_questions=request.num_questions,
            difficulty=request.difficulty,
            enable_refinement=True  # Self-refining activ√©
        )

        # Format response
        quiz_id = str(uuid.uuid4())
        questions = []

        for i, q in enumerate(quiz_data["questions"]):
            questions.append(QuizQuestion(
                id=i + 1,
                question=q["question"],
                options=q["options"][:4],
                correctAnswer=q["correctAnswer"],
                explanation=q.get("explanation", "")
            ))

        response = QuizResponse(
            id=quiz_id,
            source="text",
            difficulty=request.difficulty,
            questions=questions,
            createdAt=datetime.now().isoformat(),
            extractedText=request.course_text
        )

        print(f"‚úÖ SUCCESS: {len(questions)} questions generated from text")
        if "metadata" in quiz_data:
            print(f"   üìä Quiz quality: {quiz_data['metadata'].get('quiz_quality', {}).get('final_score', 'N/A')}%")
        print("=" * 60)

        return response

    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå ERROR: {str(e)}")
        traceback.print_exc()
        print("=" * 60)
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/flashcards/generate", response_model=FlashcardResponse)
async def generate_flashcards_endpoint(request: FlashcardGenerateRequest):
    """Generate flashcards from course text with self-refining"""
    try:
        print("=" * 60)
        print(f"üé¥ NEW FLASHCARDS REQUEST")
        print(f"   Cards: {request.num_cards}")
        print(f"   Difficulty: {request.difficulty}")
        print(f"   Text length: {len(request.course_text)} chars")

        if not request.course_text or len(request.course_text.strip()) < 10:
            raise HTTPException(
                status_code=400,
                detail="Le texte du cours est trop court ou vide"
            )

        # ‚úÖ Generate flashcards with self-refining
        flashcards_data = generate_flashcards(
            course_text=request.course_text,
            num_cards=request.num_cards,
            difficulty=request.difficulty,
            enable_refinement=True  # Self-refining activ√©
        )

        # Format response
        flashcard_id = str(uuid.uuid4())
        flashcards = []

        for card in flashcards_data["flashcards"]:
            flashcards.append(Flashcard(
                front=card["front"],
                back=card["back"],
                category=card.get("category", "G√©n√©ral"),
                difficulty=card.get("difficulty", request.difficulty)
            ))

        response = FlashcardResponse(
            id=flashcard_id,
            flashcards=flashcards,
            createdAt=datetime.now().isoformat()
        )

        print(f"‚úÖ SUCCESS: {len(flashcards)} flashcards generated")
        if "metadata" in flashcards_data:
            print(f"   üìä Quality score: {flashcards_data['metadata'].get('quality', {}).get('final_score', 'N/A')}%")
        print("=" * 60)

        return response

    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå ERROR: {str(e)}")
        traceback.print_exc()
        print("=" * 60)
        raise HTTPException(status_code=500, detail=str(e))


@app.on_event("startup")
async def startup_event():
    print("\n" + "=" * 60)
    print("üöÄ STUDIA API STARTED")
    print("=" * 60)
    print("üìç Endpoints disponibles:")
    print("   - GET  /")
    print("   - GET  /api/health")
    print("   - POST /api/quiz/generate-from-image")
    print("   - POST /api/quiz/generate-from-text")
    print("   - POST /api/flashcards/generate")
    print("=" * 60)
    print("üîÑ Self-refining: ENABLED")
    print("   ‚úì Text extraction validation")
    print("   ‚úì Quiz quality validation")
    print("   ‚úì Flashcard quality validation")
    print("=" * 60 + "\n")


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)


////////////////////////////////////////////////////////////////////////////////
FICHIER: src/studia/settings.py
////////////////////////////////////////////////////////////////////////////////
import os

# OpenAI Configuration
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# Server Configuration
API_HOST = os.getenv("API_HOST", "0.0.0.0")
API_PORT = int(os.getenv("API_PORT", 5000))


////////////////////////////////////////////////////////////////////////////////
FICHIER: src/__init__.py
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
FICHIER: src/studia/__init__.py
////////////////////////////////////////////////////////////////////////////////
"""
Studia - AI-powered learning platform
"""
__version__ = "1.0.0"


////////////////////////////////////////////////////////////////////////////////
FICHIER: src/studia/flashcard_generator.py
////////////////////////////////////////////////////////////////////////////////
"""
Flashcard Generator - Generate flashcards from course text with SELF-REFINING
"""
import json
import re
from openai import OpenAI
import os
from dotenv import load_dotenv

load_dotenv()

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))


def validate_flashcards_quality(course_text: str, flashcards_data: dict) -> dict:
    """
    üîÑ STEP 1: Validate flashcard quality and accuracy

    Returns:
    {
        "is_valid": bool,
        "quality_score": 0-100,
        "issues": [...],
        "general_feedback": str
    }
    """

    print("üîç Validating flashcards quality...")

    validation_prompt = f"""You are a flashcard quality validator. Analyze these flashcards and return your analysis in JSON format.

ORIGINAL COURSE TEXT:
{course_text}

GENERATED FLASHCARDS:
{json.dumps(flashcards_data, indent=2, ensure_ascii=False)}

CHECK THE FOLLOWING:
1. Is each "front" (question/concept) based on actual content from the course?
2. Is each "back" (answer) ACCURATE according to the course text?
3. Are the flashcards testing KEY concepts (not trivial/useless facts)?
4. Is the information complete but concise on the "back"?
5. Are there any duplicates or very similar cards?
6. Is the difficulty level appropriate?
7. Are formulas/technical terms correctly written?

Return ONLY valid JSON in this exact format:
{{
  "is_valid": true or false,
  "quality_score": 0-100,
  "issues": [
    {{
      "card_index": 0,
      "severity": "high/medium/low",
      "issue": "Description of the problem",
      "suggestion": "How to fix it"
    }}
  ],
  "general_feedback": "Overall assessment of the flashcards quality"
}}

CRITICAL RULES:
- If a flashcard uses info NOT in the course: is_valid = false, high severity
- If an answer is incomplete or wrong: is_valid = false, high severity
- quality_score = percentage of flashcards that are perfectly accurate and useful
- List ALL issues found, even small ones
- Return ONLY valid JSON"""

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        response_format={"type": "json_object"},
        messages=[
            {
                "role": "user",
                "content": validation_prompt
            }
        ],
    )

    validation_result = json.loads(response.choices[0].message.content)

    print(f"   Quality Score: {validation_result.get('quality_score', 0)}%")
    print(f"   Issues found: {len(validation_result.get('issues', []))}")

    return validation_result


def refine_flashcards(course_text: str, flashcards_data: dict, validation_result: dict) -> dict:
    """
    üîß STEP 2: Fix issues found in flashcard validation
    """

    if validation_result.get('is_valid', False) and validation_result.get('quality_score', 0) >= 90:
        print("‚úÖ Flashcards quality is excellent, no refinement needed")
        return flashcards_data

    print("üîß Refining flashcards based on validation feedback...")

    refine_prompt = f"""You are a flashcard refinement expert. FIX the issues in these flashcards and return valid JSON.

ORIGINAL COURSE TEXT:
{course_text}

CURRENT FLASHCARDS (with issues):
{json.dumps(flashcards_data, indent=2, ensure_ascii=False)}

VALIDATION ISSUES:
{json.dumps(validation_result.get('issues', []), indent=2, ensure_ascii=False)}

YOUR TASK:
1. Fix EVERY issue mentioned
2. Ensure ALL flashcards are based ONLY on the course text
3. Verify answers are complete and accurate
4. Remove duplicates if any
5. Make sure "front" is clear and "back" is comprehensive but concise

Return ONLY the CORRECTED flashcards in this EXACT JSON format:
{{
  "flashcards": [
    {{
      "front": "Question/Concept",
      "back": "Complete and accurate answer",
      "category": "Category name",
      "difficulty": "easy/medium/hard"
    }}
  ]
}}

RULES:
- Keep the SAME number of flashcards
- Base EVERYTHING on the course text
- Do NOT add external information
- Make answers specific and complete
- "front" should be short (1 sentence max)
- "back" should be concise but complete (2-3 sentences)
- Return ONLY valid JSON, nothing else"""

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        response_format={"type": "json_object"},
        messages=[
            {
                "role": "user",
                "content": refine_prompt
            }
        ],
    )

    refined_flashcards = json.loads(response.choices[0].message.content)
    print("‚úÖ Flashcards refined successfully")

    return refined_flashcards


def generate_flashcards(
        course_text: str,
        num_cards: int = 10,
        difficulty: str = "medium",
        enable_refinement: bool = True
) -> dict:
    """
    Generate flashcards from course text with SELF-REFINING

    Args:
        course_text: Text extracted from course
        num_cards: Number of flashcards to generate
        difficulty: easy, medium, or hard
        enable_refinement: Enable self-refining validation (default: True)

    Returns:
        dict: Flashcards data with metadata
    """

    print(f"üé¥ Flashcard generation started (Self-Refining: {'ON' if enable_refinement else 'OFF'})")
    print(f"   Parameters: {num_cards} cards, difficulty: {difficulty}")

    try:
        # STEP 1: Generate initial flashcards
        print("\n1Ô∏è‚É£ Generating initial flashcards...")

        difficulty_instructions = {
            "easy": "Les flashcards doivent couvrir les concepts de base et les d√©finitions simples.",
            "medium": "Les flashcards doivent aborder des concepts interm√©diaires et leurs applications.",
            "hard": "Les flashcards doivent inclure des concepts avanc√©s et des relations complexes."
        }

        prompt = f"""Tu es un assistant qui r√©pond toujours et juste en JSON. Pas de texte parasite, que du JSON.

Cr√©e {num_cards} flashcards (cartes m√©moire) bas√©es UNIQUEMENT sur ce cours.

COURS:
{course_text}

DIFFICULT√â: {difficulty}
{difficulty_instructions[difficulty]}

Le JSON doit √™tre EXACTEMENT comme ceci:
{{
  "flashcards": [
    {{
      "front": "Qu'est-ce que la photosynth√®se ?",
      "back": "La photosynth√®se est le processus par lequel les plantes convertissent la lumi√®re du soleil en √©nergie chimique.",
      "category": "Biologie",
      "difficulty": "{difficulty}"
    }},
    {{
      "front": "Formule de la photosynth√®se",
      "back": "6CO‚ÇÇ + 6H‚ÇÇO + lumi√®re ‚Üí C‚ÇÜH‚ÇÅ‚ÇÇO‚ÇÜ + 6O‚ÇÇ",
      "category": "Biologie",
      "difficulty": "{difficulty}"
    }}
  ]
}}

R√àGLES CRITIQUES:
- Exactement {num_cards} flashcards
- Chaque flashcard a :
  * "front" : la question/concept (court et clair, 1 phrase max)
  * "back" : la r√©ponse/explication (compl√®te mais concise, 2-3 phrases)
  * "category" : cat√©gorie du sujet (ex: Math√©matiques, Histoire, etc.)
  * "difficulty" : "{difficulty}"
- Varie les types : d√©finitions, formules, concepts, applications, processus
- Les r√©ponses doivent √™tre PR√âCISES et V√âRIFIABLES dans le cours
- Base-toi UNIQUEMENT sur le contenu du cours fourni (pas de connaissances externes)
- Pas de texte avant ou apr√®s le JSON, UNIQUEMENT le JSON
- Teste des concepts IMPORTANTS, pas des d√©tails insignifiants
"""

        response = client.chat.completions.create(
            model="gpt-4o-mini",
            response_format={"type": "json_object"},
            messages=[
                {
                    "role": "user",
                    "content": [{"type": "text", "text": prompt}]
                }
            ],
        )

        flashcards_json = response.choices[0].message.content

        # Clean JSON
        flashcards_json = re.sub(r"```json\n?", "", flashcards_json)
        flashcards_json = re.sub(r"```\n?", "", flashcards_json)

        # Parse JSON
        flashcards_data = json.loads(flashcards_json.strip())

        # STEP 2: Validate structure
        if "flashcards" not in flashcards_data:
            raise ValueError("Invalid flashcards format: missing 'flashcards' key")

        if len(flashcards_data["flashcards"]) != num_cards:
            print(f"‚ö†Ô∏è Warning: Expected {num_cards} flashcards, got {len(flashcards_data['flashcards'])}")

        for i, card in enumerate(flashcards_data["flashcards"]):
            if "front" not in card or "back" not in card:
                raise ValueError(f"Flashcard {i + 1}: missing 'front' or 'back' field")
            if "category" not in card:
                card["category"] = "G√©n√©ral"
            if "difficulty" not in card:
                card["difficulty"] = difficulty

        print(f"‚úÖ Initial flashcards generated: {len(flashcards_data['flashcards'])}")

        # üîÑ STEP 3: SELF-REFINING (if enabled)
        metadata = {
            "was_refined": False,
            "initial_score": 100,
            "final_score": 100
        }

        if enable_refinement:
            print("\n2Ô∏è‚É£ Validating flashcards quality...")
            validation_result = validate_flashcards_quality(course_text, flashcards_data)

            metadata["initial_score"] = validation_result.get('quality_score', 0)

            # If validation fails or score is low, refine
            if not validation_result.get('is_valid', False) or validation_result.get('quality_score', 0) < 90:
                print("\n3Ô∏è‚É£ Refining flashcards...")
                flashcards_data = refine_flashcards(course_text, flashcards_data, validation_result)

                # Re-validate after refinement
                print("\n4Ô∏è‚É£ Re-validating refined flashcards...")
                final_validation = validate_flashcards_quality(course_text, flashcards_data)

                metadata["final_score"] = final_validation.get('quality_score', 0)
                metadata["was_refined"] = True

                print(f"   ‚úÖ Flashcards refined (score: {metadata['initial_score']}% ‚Üí {metadata['final_score']}%)")
            else:
                metadata["final_score"] = validation_result.get('quality_score', 0)
                metadata["was_refined"] = False
                print(f"   ‚úÖ Flashcards quality is good ({metadata['final_score']}%)")

        # ‚ú® Add metadata to result
        flashcards_data["metadata"] = {
            "quality": metadata,
            "self_refining_enabled": enable_refinement
        }

        print(f"\n‚úÖ FINAL RESULT:")
        print(f"   Flashcards: {len(flashcards_data['flashcards'])}")
        if enable_refinement:
            print(f"   Quality score: {metadata.get('final_score', 'N/A')}%")
            print(f"   Refined: {metadata.get('was_refined', False)}")

        return flashcards_data

    except json.JSONDecodeError as e:
        print(f"‚ùå JSON Parse Error: {e}")
        raise Exception(f"Failed to parse flashcards JSON: {str(e)}")
    except Exception as e:
        print(f"‚ùå Error: {str(e)}")
        raise


////////////////////////////////////////////////////////////////////////////////
FICHIER: src/studia/quiz_generator.py
////////////////////////////////////////////////////////////////////////////////
"""
Quiz Generator - Extract text from images and generate MCQ quizzes with SELF-REFINING
"""
import os
import re
import json
from dotenv import load_dotenv
from openai import OpenAI

load_dotenv()

# OpenAI Client
api_key = os.getenv("OPENAI_API_KEY")
client = OpenAI(api_key=api_key)


def extract_text(image_base64: str) -> str:
    """
    üîÑ STEP 1: Extract text from image using GPT-4 Vision
    """

    prompt = """Extract ALL the text from this image with maximum accuracy.

RULES:
- Extract EVERYTHING: titles, paragraphs, lists, formulas, tables, diagrams labels
- Preserve the structure (use line breaks and spacing)
- Do NOT add any comments or explanations
- If mathematical formulas, write them clearly
- If tables, format them readably
- If handwritten, do your best to transcribe accurately

Return ONLY the extracted text, nothing else."""

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {
                "role": "user",
                "content": [
                    {
                        "type": "text",
                        "text": prompt
                    },
                    {
                        "type": "image_url",
                        "image_url": {
                            "url": f"data:image/jpeg;base64,{image_base64}"
                        },
                    },
                ],
            }
        ],
    )

    extracted_text = response.choices[0].message.content
    print(f"‚úÖ Text extracted: {len(extracted_text)} characters")
    return extracted_text


def verify_and_refine_extraction(image_base64: str, extracted_text: str) -> dict:
    """
    üîÑ STEP 2: Verify extraction accuracy and refine if needed
    """

    print("üîç Verifying text extraction accuracy...")

    verification_prompt = f"""You are a text extraction quality validator. Return your analysis in JSON format.

Compare the EXTRACTED TEXT with the ORIGINAL IMAGE and check:

1. Are all visible words captured?
2. Is the structure preserved (paragraphs, lists, etc.)?
3. Are formulas/equations transcribed correctly?
4. Are there any obvious errors or missing parts?
5. Is the text readable and makes sense?

EXTRACTED TEXT:
{extracted_text}

Return ONLY valid JSON:
{{
  "is_accurate": true or false,
  "confidence_score": 0-100,
  "issues": [
    {{
      "type": "missing_text/wrong_transcription/formatting_error",
      "severity": "high/medium/low",
      "description": "What's wrong",
      "location": "Where in the text"
    }}
  ],
  "needs_refinement": true or false,
  "general_assessment": "Brief overall evaluation"
}}

If confidence_score < 85%, set needs_refinement = true
Return ONLY valid JSON, nothing else."""

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        response_format={"type": "json_object"},
        messages=[
            {
                "role": "user",
                "content": [
                    {
                        "type": "text",
                        "text": verification_prompt
                    },
                    {
                        "type": "image_url",
                        "image_url": {
                            "url": f"data:image/jpeg;base64,{image_base64}"
                        },
                    },
                ],
            }
        ],
    )

    verification = json.loads(response.choices[0].message.content)
    print(f"   Confidence: {verification.get('confidence_score', 0)}%")
    print(f"   Issues found: {len(verification.get('issues', []))}")

    # If needs refinement, do a second extraction with more focus
    if verification.get('needs_refinement', False):
        print("üîß Refining text extraction...")

        issues_description = "\n".join([
            f"- {issue['description']}" for issue in verification.get('issues', [])
        ])

        refine_prompt = f"""Re-extract the text from this image with EXTRA CARE.

PREVIOUS EXTRACTION HAD THESE ISSUES:
{issues_description}

PREVIOUS EXTRACTED TEXT (for reference):
{extracted_text}

Now extract the text again, fixing these issues:
- Be more careful with formulas and special characters
- Check for missing sections
- Verify formatting and structure
- Double-check numbers and technical terms

Return ONLY the corrected extracted text, nothing else."""

        refine_response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "text",
                            "text": refine_prompt
                        },
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/jpeg;base64,{image_base64}"
                            },
                        },
                    ],
                }
            ],
        )

        refined_text = refine_response.choices[0].message.content
        print(f"‚úÖ Text refined: {len(refined_text)} characters")

        verification['refined_text'] = refined_text
        verification['was_refined'] = True
    else:
        verification['refined_text'] = extracted_text
        verification['was_refined'] = False

    return verification


def validate_quiz_quality(course_text: str, quiz_data: dict) -> dict:
    """
    üîÑ STEP 3: Validate quiz quality and accuracy
    """

    validation_prompt = f"""You are a quiz quality validator. Analyze this quiz and return your analysis in JSON format.

ORIGINAL COURSE TEXT:
{course_text}

GENERATED QUIZ:
{json.dumps(quiz_data, indent=2, ensure_ascii=False)}

CHECK THE FOLLOWING:
1. Are ALL questions based on FACTS from the course? (not general knowledge)
2. Are the correct answers ACCURATE according to the course text?
3. Are the incorrect options plausible but clearly wrong?
4. Are the explanations clear and refer to the course?
5. Is the difficulty level appropriate?
6. Do the questions test actual understanding (not just memorization)?

Return ONLY valid JSON in this exact format:
{{
  "is_valid": true or false,
  "accuracy_score": 0-100,
  "issues": [
    {{
      "question_index": 0,
      "severity": "high/medium/low",
      "issue": "Description of the problem",
      "suggestion": "How to fix it"
    }}
  ],
  "general_feedback": "Overall assessment"
}}

CRITICAL RULES:
- If a question uses info NOT in the course: is_valid = false
- If correctAnswer is wrong: is_valid = false
- accuracy_score = percentage of questions that are perfectly accurate
- Return ONLY valid JSON"""

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        response_format={"type": "json_object"},
        messages=[
            {
                "role": "user",
                "content": validation_prompt
            }
        ],
    )

    validation_result = json.loads(response.choices[0].message.content)

    print(f"üîç Quiz Validation Score: {validation_result.get('accuracy_score', 0)}%")
    print(f"   Issues found: {len(validation_result.get('issues', []))}")

    return validation_result


def refine_quiz(course_text: str, quiz_data: dict, validation_result: dict) -> dict:
    """
    üîß STEP 4: Fix issues found in quiz validation
    """

    if validation_result.get('is_valid', False) and validation_result.get('accuracy_score', 0) >= 90:
        print("‚úÖ Quiz quality is excellent, no refinement needed")
        return quiz_data

    print("üîß Refining quiz based on validation feedback...")

    refine_prompt = f"""You are a quiz refinement expert. FIX the issues in this quiz and return valid JSON.

ORIGINAL COURSE TEXT:
{course_text}

CURRENT QUIZ (with issues):
{json.dumps(quiz_data, indent=2, ensure_ascii=False)}

VALIDATION ISSUES:
{json.dumps(validation_result.get('issues', []), indent=2, ensure_ascii=False)}

YOUR TASK:
1. Fix EVERY issue mentioned
2. Ensure ALL questions are based ONLY on the course text
3. Verify correct answers are accurate
4. Improve explanations to reference the course
5. Make sure incorrect options are plausible but definitely wrong

Return ONLY the CORRECTED quiz in this EXACT JSON format:
{{
  "questions": [
    {{
      "question": "...",
      "options": ["...", "...", "...", "..."],
      "correctAnswer": 0,
      "explanation": "..."
    }}
  ]
}}

CRITICAL: Base EVERYTHING on the course text. NO external information. Return ONLY valid JSON."""

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        response_format={"type": "json_object"},
        messages=[
            {
                "role": "user",
                "content": refine_prompt
            }
        ],
    )

    refined_quiz = json.loads(response.choices[0].message.content)
    print("‚úÖ Quiz refined successfully")

    return refined_quiz


def generate_quiz_mcq(
        course_text: str,
        num_questions: int,
        difficulty: str
) -> dict:
    """Generate MCQ quiz from course text"""

    difficulty_instructions = {
        "easy": "Les questions doivent √™tre simples et directes, adapt√©es aux d√©butants.",
        "medium": "Les questions doivent √™tre de difficult√© moyenne, n√©cessitant une bonne compr√©hension du cours.",
        "hard": "Les questions doivent √™tre difficiles et exiger une connaissance approfondie du cours."
    }

    prompt = f"""Tu es un assistant qui r√©pond toujours et juste en JSON. Pas de texte parasite, que du JSON.

Cr√©e un quiz de {num_questions} questions √† choix multiples (QCM) bas√© UNIQUEMENT sur ce cours.

COURS:
{course_text}

DIFFICULT√â: {difficulty}
{difficulty_instructions[difficulty]}

Le JSON doit √™tre EXACTEMENT comme ceci:
{{
  "questions": [
    {{
      "question": "Quelle est la formule de la production mentionn√©e dans le cours?",
      "options": [
        "Production = Travail + Machines + Al√©a",
        "Production = Capital + Travail",
        "Production = Co√ªt + B√©n√©fice",
        "Production = Offre + Demande"
      ],
      "correctAnswer": 0,
      "explanation": "Selon le cours, la formule exacte est Production = Travail + Machines + Al√©a"
    }}
  ]
}}

R√àGLES CRITIQUES:
- Exactement {num_questions} questions
- Chaque question a EXACTEMENT 4 options
- correctAnswer est l'index de la bonne r√©ponse (0, 1, 2, ou 3)
- VARIE les positions: ne mets pas toujours correctAnswer √† 0
- Les options incorrectes doivent √™tre plausibles mais clairement fausses
- Chaque question doit avoir une "explanation" courte qui CITE le cours
- Base-toi UNIQUEMENT sur le contenu du cours fourni (pas de connaissances externes)
- Les questions doivent √™tre PR√âCISES et V√âRIFIABLES dans le cours
- Pas de texte avant ou apr√®s le JSON, UNIQUEMENT le JSON
"""

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        response_format={"type": "json_object"},
        messages=[
            {
                "role": "user",
                "content": prompt
            }
        ],
    )

    quiz_data = json.loads(response.choices[0].message.content)
    print("‚úÖ Initial quiz generated")

    return quiz_data


def quiz_generator_from_image(
        image_base64: str,
        num_questions: int = 5,
        difficulty: str = "medium",
        enable_refinement: bool = True
) -> dict:
    """
    Generate quiz from course image with COMPLETE SELF-REFINING
    """

    print(f"üì∏ Quiz generation started (Self-Refining: {'ON' if enable_refinement else 'OFF'})")
    print(f"   Parameters: {num_questions} questions, difficulty: {difficulty}")

    try:
        # üîÑ STEP 1: Extract text from image
        print("\n1Ô∏è‚É£ Extracting text from image...")
        course_text = extract_text(image_base64)

        if not course_text or len(course_text.strip()) < 10:
            raise ValueError("Failed to extract text from image or text too short")

        extraction_metadata = {
            "initial_length": len(course_text),
            "was_refined": False,
            "confidence_score": 100
        }

        # üîÑ STEP 2: Verify and refine extraction (if enabled)
        if enable_refinement:
            print("\n2Ô∏è‚É£ Verifying text extraction...")
            verification = verify_and_refine_extraction(image_base64, course_text)

            if verification.get('was_refined', False):
                course_text = verification['refined_text']
                print(f"   ‚úÖ Text was refined (confidence: {verification.get('confidence_score', 0)}%)")

            extraction_metadata = {
                "initial_length": extraction_metadata["initial_length"],
                "final_length": len(course_text),
                "was_refined": verification.get('was_refined', False),
                "confidence_score": verification.get('confidence_score', 0),
                "issues_found": len(verification.get('issues', []))
            }

        # üîÑ STEP 3: Generate quiz
        print(f"\n3Ô∏è‚É£ Generating quiz ({num_questions} questions, {difficulty})...")
        quiz_data = generate_quiz_mcq(course_text, num_questions, difficulty)

        # Validate structure
        if "questions" not in quiz_data:
            raise ValueError("Invalid quiz format: missing 'questions' key")

        # Validate each question
        for i, q in enumerate(quiz_data["questions"]):
            if "question" not in q:
                raise ValueError(f"Question {i + 1}: missing 'question' field")
            if "options" not in q or len(q["options"]) != 4:
                raise ValueError(f"Question {i + 1}: must have exactly 4 options")
            if "correctAnswer" not in q:
                raise ValueError(f"Question {i + 1}: missing 'correctAnswer' field")
            if not (0 <= q["correctAnswer"] <= 3):
                raise ValueError(f"Question {i + 1}: correctAnswer must be 0-3")
            if "explanation" not in q:
                q["explanation"] = ""

        # üîÑ STEP 4: Validate and refine quiz (if enabled)
        quiz_metadata = {
            "was_refined": False,
            "initial_score": 100,
            "final_score": 100
        }

        if enable_refinement:
            print("\n4Ô∏è‚É£ Validating quiz quality...")
            validation_result = validate_quiz_quality(course_text, quiz_data)

            quiz_metadata["initial_score"] = validation_result.get('accuracy_score', 0)

            # If validation fails or score is low, refine
            if not validation_result.get('is_valid', False) or validation_result.get('accuracy_score', 0) < 90:
                print("\n5Ô∏è‚É£ Refining quiz...")
                quiz_data = refine_quiz(course_text, quiz_data, validation_result)

                # Re-validate after refinement
                print("\n6Ô∏è‚É£ Re-validating refined quiz...")
                final_validation = validate_quiz_quality(course_text, quiz_data)

                quiz_metadata["final_score"] = final_validation.get('accuracy_score', 0)
                quiz_metadata["was_refined"] = True

                print(f"   ‚úÖ Quiz refined (score: {quiz_metadata['initial_score']}% ‚Üí {quiz_metadata['final_score']}%)")
            else:
                quiz_metadata["final_score"] = validation_result.get('accuracy_score', 0)
                quiz_metadata["was_refined"] = False
                print(f"   ‚úÖ Quiz quality is good ({quiz_metadata['final_score']}%)")

        # ‚ú® Add metadata to result
        quiz_data["extractedText"] = course_text
        quiz_data["metadata"] = {
            "extraction": extraction_metadata,
            "quiz_quality": quiz_metadata,
            "self_refining_enabled": enable_refinement
        }

        print(f"\n‚úÖ FINAL RESULT:")
        print(f"   Questions: {len(quiz_data['questions'])}")
        print(f"   Text length: {len(course_text)} characters")
        if enable_refinement:
            print(f"   Text confidence: {extraction_metadata.get('confidence_score', 'N/A')}%")
            print(f"   Quiz quality: {quiz_metadata.get('final_score', 'N/A')}%")
            print(f"   Refinements: Text={extraction_metadata.get('was_refined', False)}, Quiz={quiz_metadata.get('was_refined', False)}")

        return quiz_data

    except json.JSONDecodeError as e:
        print(f"‚ùå JSON Parse Error: {e}")
        raise Exception(f"Failed to parse quiz JSON: {str(e)}")
    except Exception as e:
        print(f"‚ùå Error: {str(e)}")
        raise


def quiz_generator_from_text(
        course_text: str,
        num_questions: int = 5,
        difficulty: str = "medium",
        enable_refinement: bool = True
) -> dict:
    """
    Generate quiz from course text with SELF-REFINING
    """

    print(f"üìù Quiz generation from text (Self-Refining: {'ON' if enable_refinement else 'OFF'})")

    try:
        # Generate quiz
        print("1Ô∏è‚É£ Generating quiz...")
        quiz_data = generate_quiz_mcq(course_text, num_questions, difficulty)

        # Validate structure
        if "questions" not in quiz_data:
            raise ValueError("Invalid quiz format: missing 'questions' key")

        quiz_metadata = {
            "was_refined": False,
            "initial_score": 100,
            "final_score": 100
        }

        # Validate and refine (if enabled)
        if enable_refinement:
            print("2Ô∏è‚É£ Validating quiz quality...")
            validation_result = validate_quiz_quality(course_text, quiz_data)

            quiz_metadata["initial_score"] = validation_result.get('accuracy_score', 0)

            if not validation_result.get('is_valid', False) or validation_result.get('accuracy_score', 0) < 90:
                print("3Ô∏è‚É£ Refining quiz...")
                quiz_data = refine_quiz(course_text, quiz_data, validation_result)

                final_validation = validate_quiz_quality(course_text, quiz_data)
                quiz_metadata["final_score"] = final_validation.get('accuracy_score', 0)
                quiz_metadata["was_refined"] = True
            else:
                quiz_metadata["final_score"] = validation_result.get('accuracy_score', 0)

        quiz_data["metadata"] = {
            "quiz_quality": quiz_metadata,
            "self_refining_enabled": enable_refinement
        }

        print(f"‚úÖ Quiz generated: {len(quiz_data['questions'])} questions")
        if enable_refinement:
            print(f"   Quality score: {quiz_metadata.get('final_score', 'N/A')}%")

        return quiz_data

    except Exception as e:
        print(f"‚ùå Error: {str(e)}")
        raise


////////////////////////////////////////////////////////////////////////////////
FICHIER: src/toto.py
////////////////////////////////////////////////////////////////////////////////

tutu = {
  "quiz": {
      "question": "Comment la production est-elle d√©finie selon le cours ?",
      "answer": "La production est une activit√© socialement organis√©e qui permet de cr√©er des biens et des services."
  }
}


////////////////////////////////////////////////////////////////////////////////
FICHIER: src/studia/quiz.json
////////////////////////////////////////////////////////////////////////////////

[
    {
        "question": "Quelle est la formule de la production selon le cours?",
        "answer": "Production = Travail humain + Machines + Mat√©riel permanent (capital)"
    },
    {
        "question": "Quel organisme est repr√©sent√© par l'acronyme Insee?",
        "answer": "Institut national de la statistique et des √©tudes √©conomiques"
    },
    {
        "question": "Comment doit-on consid√©rer la production selon le cours?",
        "answer": "Comme une activit√© socialement organis√©e visant √† cr√©er des biens et des services."
    },
    {
        "question": "Qu'est-ce qu'un mod√®le dans le contexte du cours?",
        "answer": "Une repr√©sentation simplifi√©e de la r√©alit√©, qui ne retient que quelques √©l√©ments frais d‚Äôalgorithmes de causalit√© entre eux."
    },
    {
        "question": "Quels sont les trois √©l√©ments composant le sch√©ma de la production dans le cours?",
        "answer": "Production, Consommation, Repartition des ressources"
    },
    {
        "question": "Comment d√©finit-on un bien?",
        "answer": "Un produit mat√©riel r√©sultant de la production."
    },
    {
        "question": "Comment d√©finit-on un service?",
        "answer": "Un produit immat√©riel r√©sultant de la production."
    },
    {
        "question": "Quels sont les deux types de production mentionn√©s dans le cours?",
        "answer": "Marchande et Non marchande."
    },
    {
        "question": "Qu'est-ce que la production marchande?",
        "answer": "La production propos√©e et vendue sur le march√© en une qui couvre au moins les co√ªts de production."
    },
    {
        "question": "Qu'est-ce que la production non marchande?",
        "answer": "La production non marchande correspond aux services offerts gratuitement ou pour gratuitement par les administrations publiques."
    }
]



////////////////////////////////////////////////////////////////////////////////
FICHIER: src/studia/quiz_ses.md
////////////////////////////////////////////////////////////////////////////////
# Quiz SES sur la Production

## Introduction
Ce quiz est bas√© sur le cours de Sciences √âconomiques et Sociales (SES) concernant la production. Les questions augmentent progressivement en difficult√©.

---

## Questions de Niveau 1 : Connaissance de base

1. **Question 1** : Quel est le r√¥le de l'Insee ?
   - A) Produire des biens
   - B) √âvaluer les entreprises
   - C) R√©aliser des √©tudes statistiques
   - D) G√©rer l'√©conomie nationale

   **R√©ponse** : C) R√©aliser des √©tudes statistiques.

2. **Question 2** : Qu'est-ce qu'un bien ?
   - A) Un service offert gratuitement
   - B) Un produit mat√©riel r√©sultant de la production
   - C) Un √©l√©ment de capital
   - D) Une activit√© humaine

   **R√©ponse** : B) Un produit mat√©riel r√©sultant de la production.

---

## Questions de Niveau 2 : Application

3. **Question 3** : Quelles sont les trois composantes essentielles de la production selon le cours ?
   - A) Travail humain, machines, capital
   - B) Services, biens, administration
   - C) Ressources naturelles, travail humain, innovations
   - D) √âconomie, march√©, consommation

   **R√©ponse** : A) Travail humain, machines, capital.

4. **Question 4** : Si une entreprise produit des v√™tements qu'elle propose √† la vente pour r√©aliser un b√©n√©fice, quel type de production cela repr√©sente-t-il ?
   - A) Non marchande
   - B) Marchande
   - C) Publique
   - D) Communautaire

   **R√©ponse** : B) Marchande.

---

## Questions de Niveau 3 : R√©flexion

5. **Question 5** : Pourquoi une production non marchande est-elle importante pour l'√©conomie ?
   - A) Elle permet de g√©n√©rer des profits.
   - B) Elle contribue √† la satisfaction des besoins communautaires et sociaux sans √©change mon√©taire.
   - C) Elle cr√©e de la concurrence sur le march√©.
   - D) Elle repose sur des investissements priv√©s.

   **R√©ponse** : B) Elle contribue √† la satisfaction des besoins communautaires et sociaux sans √©change mon√©taire.

6. **Question 6** : En quoi un mod√®le √©conomique est-il une repr√©sentation simplifi√©e de la r√©alit√© ? Donnez un exemple.
   - **R√©ponse attendue** : Un mod√®le √©conomique ne prend en compte que certains √©l√©ments essentiels de l'√©conomie, facilitant ainsi l'analyse. Par exemple, le mod√®le de l'offre et de la demande ignore d'autres facteurs comme les politiques fiscales ou les comportements des consommateurs.

---

## Conclusion
Ce quiz permet de tester les connaissances de base sur la production √† partir des concepts pr√©sent√©s, tout en encourageant une r√©flexion plus profonde sur les implications des types de production dans l'√©conomie.


////////////////////////////////////////////////////////////////////////////////
FICHIER: app/api/waitlist/route.ts
////////////////////////////////////////////////////////////////////////////////
import { NextResponse } from 'next/server';

export async function POST(request: Request) {
  try {
    const { email, language } = await request.json();

    // Validate email
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return NextResponse.json(
        { error: 'Invalid email address' },
        { status: 400 }
      );
    }

    // Send to Web3Forms
    const formData = {
      access_key: '0a691a94-8de8-445c-82b1-a5accf0d48f7', // ‚ö†Ô∏è REMPLACE PAR TA VRAIE CL√â
      subject: `üéâ New Studia Waitlist Signup!`,
      from_name: 'Studia Waitlist',
      email: email,
      message: `New signup!\n\nEmail: ${email}\nLanguage: ${language}\nTime: ${new Date().toLocaleString()}\n\nTotal signups so far: Check your inbox!`,
    };

    const response = await fetch('https://api.web3forms.com/submit', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(formData),
    });

    if (!response.ok) {
      throw new Error('Failed to send email');
    }

    console.log(`‚úÖ Signup: ${email} (${language})`);

    return NextResponse.json(
      { message: 'Successfully added to waitlist!' },
      { status: 201 }
    );
  } catch (error) {
    console.error('‚ùå Error:', error);
    return NextResponse.json(
      { error: 'Failed to add to waitlist' },
      { status: 500 }
    );
  }
}



////////////////////////////////////////////////////////////////////////////////
FICHIER: app/layout.tsx
////////////////////////////////////////////////////////////////////////////////
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { LanguageProvider } from "@/contexts/LanguageContext";
import { ClerkProvider } from '@clerk/nextjs';
import Script from 'next/script';

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Studia - AI-Powered Learning Platform",
  description: "Automate your learning with AI. Create flashcards, generate quizzes, and study smarter with Studia.",
  manifest: '/manifest.json', // ‚úÖ Ajout√©
  themeColor: '#3b82f6',
  appleWebApp: {
    capable: true,
    statusBarStyle: 'default',
    title: 'Studia'
  }
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <ClerkProvider>
      <html lang="en" className="scroll-smooth" suppressHydrationWarning>
        <head>
          {/* PWA Meta Tags */}
          <link rel="apple-touch-icon" href="/icons/icon-192x192.png" />
          <meta name="apple-mobile-web-app-capable" content="yes" />
          <meta name="apple-mobile-web-app-status-bar-style" content="default" />
        </head>
        <body className={`${inter.className} bg-white dark:bg-dark-50 text-gray-900 dark:text-white transition-colors`}>
          <LanguageProvider>
            {children}
          </LanguageProvider>

          {/* PWA Init Script */}
          <Script id="pwa-init" strategy="afterInteractive">
            {`
              if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                  navigator.serviceWorker.register('/sw.js')
                    .then(reg => console.log('‚úÖ SW registered'))
                    .catch(err => console.error('‚ùå SW error:', err));
                });
              }
            `}
          </Script>

          {/* Google Analytics */}
          <Script
            src="https://www.googletagmanager.com/gtag/js?id=G-TCC99EXG30"
            strategy="afterInteractive"
          />
          <Script id="google-analytics" strategy="afterInteractive">
            {`
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-TCC99EXG30');
            `}
          </Script>
        </body>
      </html>
    </ClerkProvider>
  );
}


////////////////////////////////////////////////////////////////////////////////
FICHIER: app/page.tsx
////////////////////////////////////////////////////////////////////////////////
import Navbar from '@/components/Navbar';
import Hero from '@/components/Hero';
import About from '@/components/About';
import Features from '@/components/Features';
import WhyStudia from '@/components/WhyStudia';
import Creator from '@/components/Creator';
import CTA from '@/components/CTA';
import Footer from '@/components/Footer';

export default function Home() {
  return (
    <main className="min-h-screen">
      <Navbar />
      <Hero />
      <About />
      <Features />
      <WhyStudia />
      <Creator />
      <CTA />
      <Footer />
    </main>
  );
}


////////////////////////////////////////////////////////////////////////////////
FICHIER: app/sign-in/[[...sign-in]]/page.tsx
////////////////////////////////////////////////////////////////////////////////
import { SignIn } from '@clerk/nextjs';

export default function SignInPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-b from-gray-50 to-white">
      <SignIn />
    </div>
  );
}


////////////////////////////////////////////////////////////////////////////////
FICHIER: app/sign-up/[[...sign-up]]/page.tsx
////////////////////////////////////////////////////////////////////////////////
import { SignUp } from '@clerk/nextjs';

export default function SignUpPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-b from-gray-50 to-white">
      <SignUp />
    </div>
  );
}


////////////////////////////////////////////////////////////////////////////////
FICHIER: app/workspace/capture/page.tsx
////////////////////////////////////////////////////////////////////////////////
'use client';

import { useState } from 'react';
import { useUser } from '@clerk/nextjs';
import { useRouter } from 'next/navigation';
import { Loader2, ArrowLeft, Check } from 'lucide-react';
import { saveCourse } from '@/lib/courseService';
import { extractTextFromMultipleImages } from '@/lib/api';
import MultiImageCapture from '@/components/workspace/MultiImageCapture';

export default function CapturePage() {
  const { user } = useUser();
  const router = useRouter();

  const [selectedImages, setSelectedImages] = useState<string[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);

  const handleImagesSelected = (images: string[]) => {
    setSelectedImages(images);
    setError(null);
  };

  const handleExtract = async () => {
    if (!user || selectedImages.length === 0) return;

    try {
      setLoading(true);
      setError(null);

      console.log(`üì∏ Extraction de ${selectedImages.length} images...`);

      const result = await extractTextFromMultipleImages(selectedImages);

      console.log(`‚úÖ ${result.pagesExtracted} pages extraites`);

      // Sauvegarder le cours
      const course = await saveCourse(
        user.id,
        result.extractedText,
        `Cours - ${result.totalImages} pages - ${new Date().toLocaleDateString('fr-FR')}`
      );

      console.log('‚úÖ Cours sauvegard√©, ID:', course.id);

      setSuccess(true);

      // Rediriger apr√®s 2 secondes
      setTimeout(() => {
        router.push(`/workspace/courses/${course.id}`);
      }, 2000);

    } catch (err: any) {
      console.error('‚ùå Erreur:', err);
      setError(err.message || 'Erreur lors de l\'extraction');
    } finally {
      setLoading(false);
    }
  };

  if (success) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50 px-4">
        <div className="bg-white rounded-2xl shadow-xl p-8 max-w-md w-full text-center">
          <div className="w-20 h-20 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-6">
            <Check className="text-green-600" size={40} />
          </div>
          <h2 className="text-2xl font-bold text-gray-900 mb-2">
            ‚úÖ Cours Sauvegard√© !
          </h2>
          <p className="text-gray-600">
            Redirection vers votre cours...
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50 py-12 px-4">
      <div className="max-w-4xl mx-auto">

        <button
          onClick={() => router.push('/workspace')}
          className="flex items-center text-gray-600 hover:text-gray-900 mb-6 transition-colors"
          disabled={loading}
        >
          <ArrowLeft size={20} className="mr-2" />
          Retour au Workspace
        </button>

        <div className="text-center mb-8">
          <h1 className="text-4xl md:text-5xl font-bold text-gray-900 mb-4">
            üì∏ Capturer un Cours
          </h1>
          <p className="text-lg text-gray-600">
            Prenez plusieurs photos de votre cours (maximum 10 pages)
          </p>
        </div>

        {selectedImages.length === 0 ? (
          <MultiImageCapture
            onImagesSelected={handleImagesSelected}
            maxImages={10}
          />
        ) : (
          <div className="space-y-6">
            <MultiImageCapture
              onImagesSelected={handleImagesSelected}
              maxImages={10}
            />

            <div className="bg-white rounded-2xl shadow-xl p-6 border border-gray-100">
              <button
                onClick={handleExtract}
                disabled={loading}
                className="w-full bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 text-white font-bold py-4 px-6 rounded-xl transition-all shadow-lg hover:shadow-xl transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none flex items-center justify-center space-x-2"
              >
                {loading ? (
                  <>
                    <Loader2 className="animate-spin" size={20} />
                    <span>Extraction en cours...</span>
                  </>
                ) : (
                  <>
                    <span>‚ú® Extraire et Sauvegarder ({selectedImages.length} photos)</span>
                  </>
                )}
              </button>

              {error && (
                <div className="mt-4 p-4 bg-red-50 border border-red-200 rounded-lg">
                  <p className="text-sm text-red-600">‚ùå {error}</p>
                </div>
              )}

              {loading && (
                <div className="mt-4 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                  <div className="flex items-center space-x-3">
                    <Loader2 className="animate-spin text-blue-600" size={20} />
                    <div className="flex-1">
                      <p className="text-sm font-medium text-blue-900">
                        Extraction en cours...
                      </p>
                      <p className="text-xs text-blue-700">
                        Traitement de {selectedImages.length} images avec OCR
                      </p>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>
        )}

      </div>
    </div>
  );
}


////////////////////////////////////////////////////////////////////////////////
FICHIER: app/workspace/courses/[id]/generate-flashcards/page.tsx
////////////////////////////////////////////////////////////////////////////////
'use client';

import { useState, useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';
import { useUser } from '@clerk/nextjs';
import { getCourseById, Course } from '@/lib/courseService';
import { generateFlashcards } from '@/lib/api';
import { saveFlashcardDeck } from '@/lib/flashcardService';
import { ArrowLeft, Loader2 } from 'lucide-react';
import FlashcardViewer from '@/components/workspace/FlashcardViewer';
import { Flashcard } from '@/lib/flashcardService';

type Step = 'config' | 'generating' | 'reviewing' | 'saved';

export default function GenerateFlashcardsPage() {
  const params = useParams();
  const router = useRouter();
  const { user, isLoaded } = useUser();
  const [course, setCourse] = useState<Course | null>(null);
  const [loading, setLoading] = useState(true);
  const [step, setStep] = useState<Step>('config');
  const [flashcards, setFlashcards] = useState<Flashcard[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [deckId, setDeckId] = useState<number | null>(null);

  const [numCards, setNumCards] = useState(10);
  const [difficulty, setDifficulty] = useState<'easy' | 'medium' | 'hard'>('medium');

  useEffect(() => {
    if (isLoaded && user && params.id) {
      loadCourse();
    }
  }, [isLoaded, user, params.id]);

  const loadCourse = async () => {
    if (!user) return;

    try {
      const data = await getCourseById(Number(params.id), user.id);
      if (!data) {
        router.push('/workspace/courses');
        return;
      }
      setCourse(data);
    } catch (err) {
      console.error('Erreur:', err);
      router.push('/workspace/courses');
    } finally {
      setLoading(false);
    }
  };

  const handleGenerate = async () => {
    if (!course || !user) return;

    try {
      setStep('generating');
      setError(null);

      console.log('üé¥ G√©n√©ration flashcards depuis texte du cours...');

      const result = await generateFlashcards(
        course.extracted_text,
        numCards,
        difficulty
      );

      console.log('‚úÖ Flashcards g√©n√©r√©es:', result.flashcards.length);
      setFlashcards(result.flashcards);

      // Sauvegarder automatiquement
      console.log('üíæ Sauvegarde du deck...');
      const deck = await saveFlashcardDeck(
        user.id,
        result.flashcards,
        `Flashcards - ${course.title}`,
        difficulty,
        course.id
      );

      console.log('‚úÖ Deck sauvegard√©, ID:', deck.id);
      setDeckId(deck.id);
      setStep('reviewing');

    } catch (err: any) {
      console.error('‚ùå Erreur:', err);
      setError(err.message);
      setStep('config');
    }
  };

  const handleSaveAndExit = () => {
    setStep('saved');
    setTimeout(() => {
      router.push(`/workspace/courses/${params.id}`);
    }, 2000);
  };

  if (!isLoaded || loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50">
        <Loader2 className="animate-spin h-12 w-12 text-blue-600" />
      </div>
    );
  }

  if (!course) return null;

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50 py-12 px-4">
      <div className="max-w-4xl mx-auto">
        {/* Back Button */}
        {step !== 'saved' && (
          <button
            onClick={() => router.push(`/workspace/courses/${params.id}`)}
            className="flex items-center text-gray-600 hover:text-gray-900 mb-6 transition-colors"
          >
            <ArrowLeft size={20} className="mr-2" />
            Retour au cours
          </button>
        )}

        {/* Header */}
        <div className="text-center mb-8">
          <h1 className="text-4xl font-bold text-gray-900 mb-2">
            üé¥ G√©n√©rer des Flashcards
          </h1>
          <p className="text-lg text-gray-600">
            Depuis : {course.title}
          </p>
        </div>

        {/* Content selon l'√©tape */}
        {step === 'config' && (
          <div className="bg-white rounded-2xl shadow-xl p-8 border border-gray-100">
            <h3 className="text-xl font-bold text-gray-900 mb-6">‚öôÔ∏è Configuration</h3>

            {/* Number of Cards */}
            <div className="mb-6">
              <label className="block text-sm font-medium text-gray-700 mb-3">
                Nombre de flashcards : <span className="text-purple-600 font-bold">{numCards}</span>
              </label>
              <input
                type="range"
                min="5"
                max="20"
                value={numCards}
                onChange={(e) => setNumCards(Number(e.target.value))}
                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-purple-600"
              />
              <div className="flex justify-between text-xs text-gray-500 mt-1">
                <span>5</span>
                <span>20</span>
              </div>
            </div>

            {/* Difficulty */}
            <div className="mb-6">
              <label className="block text-sm font-medium text-gray-700 mb-3">
                Difficult√©
              </label>
              <div className="flex gap-3">
                {(['easy', 'medium', 'hard'] as const).map((level) => (
                  <button
                    key={level}
                    onClick={() => setDifficulty(level)}
                    className={`flex-1 px-4 py-3 rounded-lg font-medium transition-all transform hover:scale-105 ${
                      difficulty === level
                        ? 'bg-purple-600 text-white shadow-lg'
                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                    }`}
                  >
                    {level === 'easy' && 'üòä Facile'}
                    {level === 'medium' && 'üéØ Moyen'}
                    {level === 'hard' && 'üî• Difficile'}
                  </button>
                ))}
              </div>
            </div>

            {/* Info Box */}
            <div className="mb-6 p-4 bg-purple-50 rounded-lg border border-purple-200">
              <h4 className="font-semibold text-purple-900 mb-2">üìö √Ä propos des flashcards :</h4>
              <ul className="text-sm text-purple-800 space-y-1">
                <li>‚úì Questions au recto, r√©ponses au verso</li>
                <li>‚úì Concepts cl√©s, d√©finitions, formules</li>
                <li>‚úì M√©thode de r√©p√©tition espac√©e</li>
                <li>‚úì Suivez votre progression</li>
              </ul>
            </div>

            {/* Generate Button */}
            <button
              onClick={handleGenerate}
              className="w-full bg-gradient-to-r from-purple-600 to-purple-700 hover:from-purple-700 hover:to-purple-800 text-white font-bold py-4 px-6 rounded-xl transition-all duration-300 shadow-lg hover:shadow-xl transform hover:scale-105"
            >
              ‚ú® G√©n√©rer les Flashcards
            </button>

            {/* Error */}
            {error && (
              <div className="mt-4 p-4 bg-red-50 border border-red-200 rounded-lg">
                <p className="text-sm text-red-600">‚ùå {error}</p>
              </div>
            )}

            {/* Course Info */}
            <div className="mt-6 p-4 bg-blue-50 rounded-lg border border-blue-200">
              <p className="text-sm text-blue-800">
                <strong>üìö Texte du cours :</strong> {course.extracted_text.length} caract√®res
              </p>
            </div>
          </div>
        )}

        {step === 'generating' && (
          <div className="bg-white rounded-2xl shadow-xl p-12 text-center">
            <Loader2 className="animate-spin h-16 w-16 text-purple-600 mx-auto mb-6" />
            <h3 className="text-2xl font-bold text-gray-900 mb-2">
              G√©n√©ration en cours...
            </h3>
            <p className="text-gray-600">
              Cr√©ation de {numCards} flashcards depuis votre cours
            </p>
            <div className="mt-6 flex justify-center space-x-2">
              <div className="w-3 h-3 bg-purple-600 rounded-full animate-bounce"></div>
              <div className="w-3 h-3 bg-purple-600 rounded-full animate-bounce" style={{ animationDelay: '0.1s' }}></div>
              <div className="w-3 h-3 bg-purple-600 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
            </div>
          </div>
        )}

        {step === 'reviewing' && flashcards.length > 0 && (
          <div className="space-y-6">
            <div className="bg-white rounded-2xl shadow-xl p-6 border border-gray-100">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-xl font-bold text-gray-900">
                  ‚úÖ Flashcards g√©n√©r√©es !
                </h3>
                <button
                  onClick={handleSaveAndExit}
                  className="px-6 py-2 bg-green-600 text-white rounded-lg font-semibold hover:bg-green-700 transition-all"
                >
                  ‚úì Terminer
                </button>
              </div>
              <p className="text-gray-600">
                {flashcards.length} cartes cr√©√©es. Commencez la r√©vision ci-dessous.
              </p>
            </div>

            <div className="bg-white rounded-2xl shadow-xl p-8 border border-gray-100">
              <FlashcardViewer flashcards={flashcards} />
            </div>

            <div className="text-center">
              <button
                onClick={() => router.push(`/workspace/flashcards/${deckId}`)}
                className="px-8 py-3 bg-purple-600 text-white rounded-xl font-bold hover:bg-purple-700 transition-all shadow-lg"
              >
                R√©viser plus tard
              </button>
            </div>
          </div>
        )}

        {step === 'saved' && (
          <div className="bg-white rounded-2xl shadow-xl p-12 text-center">
            <div className="w-20 h-20 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-6">
              <span className="text-4xl">‚úÖ</span>
            </div>
            <h3 className="text-2xl font-bold text-gray-900 mb-2">
              Flashcards sauvegard√©es !
            </h3>
            <p className="text-gray-600">
              Redirection vers le cours...
            </p>
          </div>
        )}
      </div>
    </div>
  );
}


////////////////////////////////////////////////////////////////////////////////
FICHIER: app/workspace/courses/[id]/generate-quiz/page.tsx
////////////////////////////////////////////////////////////////////////////////
'use client';

import { useState, useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';
import { useUser } from '@clerk/nextjs';
import { getCourseById, Course } from '@/lib/courseService';
import { generateQuizFromText, Quiz } from '@/lib/api';
import { ArrowLeft, Loader2 } from 'lucide-react';
import QuizDisplay from '@/components/workspace/QuizDisplay';
import QuizResults from '@/components/workspace/QuizResults';

type Step = 'config' | 'generating' | 'taking' | 'results';

export default function GenerateQuizPage() {
  const params = useParams();
  const router = useRouter();
  const { user, isLoaded } = useUser();
  const [course, setCourse] = useState<Course | null>(null);
  const [loading, setLoading] = useState(true);
  const [step, setStep] = useState<Step>('config');
  const [quiz, setQuiz] = useState<Quiz | null>(null);
  const [userAnswers, setUserAnswers] = useState<number[]>([]);
  const [error, setError] = useState<string | null>(null);

  const [numQuestions, setNumQuestions] = useState(5);
  const [difficulty, setDifficulty] = useState<'easy' | 'medium' | 'hard'>('medium');

  useEffect(() => {
    if (isLoaded && user && params.id) {
      loadCourse();
    }
  }, [isLoaded, user, params.id]);

  const loadCourse = async () => {
    if (!user) return;

    try {
      const data = await getCourseById(Number(params.id), user.id);
      if (!data) {
        router.push('/workspace/courses');
        return;
      }
      setCourse(data);
    } catch (err) {
      console.error('Erreur:', err);
      router.push('/workspace/courses');
    } finally {
      setLoading(false);
    }
  };

  const handleGenerate = async () => {
    if (!course) return;

    try {
      setStep('generating');
      setError(null);

      console.log('üéØ G√©n√©ration quiz depuis texte du cours...');

      const generatedQuiz = await generateQuizFromText(
        course.extracted_text,
        numQuestions,
        difficulty
      );

      console.log('‚úÖ Quiz g√©n√©r√©:', generatedQuiz);
      setQuiz(generatedQuiz);
      setStep('taking');

    } catch (err: any) {
      console.error('‚ùå Erreur:', err);
      setError(err.message);
      setStep('config');
    }
  };

  const handleQuizCompleted = (answers: number[]) => {
    setUserAnswers(answers);
    setStep('results');
  };

  const handleRetake = () => {
    setUserAnswers([]);
    setStep('taking');
  };

  const handleNewQuiz = () => {
    setQuiz(null);
    setUserAnswers([]);
    setStep('config');
  };

  if (!isLoaded || loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50">
        <Loader2 className="animate-spin h-12 w-12 text-blue-600" />
      </div>
    );
  }

  if (!course) return null;

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50 py-12 px-4">
      <div className="max-w-4xl mx-auto">
        {/* Back Button */}
        {step !== 'taking' && step !== 'results' && (
          <button
            onClick={() => router.push(`/workspace/courses/${params.id}`)}
            className="flex items-center text-gray-600 hover:text-gray-900 mb-6 transition-colors"
          >
            <ArrowLeft size={20} className="mr-2" />
            Retour au cours
          </button>
        )}

        {/* Header */}
        <div className="text-center mb-8">
          <h1 className="text-4xl font-bold text-gray-900 mb-2">
            üìù G√©n√©rer un Quiz
          </h1>
          <p className="text-lg text-gray-600">
            Depuis : {course.title}
          </p>
        </div>

        {/* Content selon l'√©tape */}
        {step === 'config' && (
          <div className="bg-white rounded-2xl shadow-xl p-8 border border-gray-100">
            <h3 className="text-xl font-bold text-gray-900 mb-6">‚öôÔ∏è Configuration</h3>

            {/* Number of Questions */}
            <div className="mb-6">
              <label className="block text-sm font-medium text-gray-700 mb-3">
                Nombre de questions : <span className="text-blue-600 font-bold">{numQuestions}</span>
              </label>
              <input
                type="range"
                min="3"
                max="15"
                value={numQuestions}
                onChange={(e) => setNumQuestions(Number(e.target.value))}
                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
              />
              <div className="flex justify-between text-xs text-gray-500 mt-1">
                <span>3</span>
                <span>15</span>
              </div>
            </div>

            {/* Difficulty */}
            <div className="mb-6">
              <label className="block text-sm font-medium text-gray-700 mb-3">
                Difficult√©
              </label>
              <div className="flex gap-3">
                {(['easy', 'medium', 'hard'] as const).map((level) => (
                  <button
                    key={level}
                    onClick={() => setDifficulty(level)}
                    className={`flex-1 px-4 py-3 rounded-lg font-medium transition-all transform hover:scale-105 ${
                      difficulty === level
                        ? 'bg-blue-600 text-white shadow-lg'
                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                    }`}
                  >
                    {level === 'easy' && 'üòä Facile'}
                    {level === 'medium' && 'üéØ Moyen'}
                    {level === 'hard' && 'üî• Difficile'}
                  </button>
                ))}
              </div>
            </div>

            {/* Generate Button */}
            <button
              onClick={handleGenerate}
              className="w-full bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 text-white font-bold py-4 px-6 rounded-xl transition-all duration-300 shadow-lg hover:shadow-xl transform hover:scale-105"
            >
              ‚ú® G√©n√©rer le Quiz
            </button>

            {/* Error */}
            {error && (
              <div className="mt-4 p-4 bg-red-50 border border-red-200 rounded-lg">
                <p className="text-sm text-red-600">‚ùå {error}</p>
              </div>
            )}

            {/* Info */}
            <div className="mt-6 p-4 bg-blue-50 rounded-lg border border-blue-200">
              <p className="text-sm text-blue-800">
                <strong>üìö Texte du cours :</strong> {course.extracted_text.length} caract√®res
              </p>
              <p className="text-xs text-blue-700 mt-2">
                Le quiz sera g√©n√©r√© √† partir du texte extrait de votre cours.
              </p>
            </div>
          </div>
        )}

        {step === 'generating' && (
          <div className="bg-white rounded-2xl shadow-xl p-12 text-center">
            <Loader2 className="animate-spin h-16 w-16 text-blue-600 mx-auto mb-6" />
            <h3 className="text-2xl font-bold text-gray-900 mb-2">
              G√©n√©ration en cours...
            </h3>
            <p className="text-gray-600">
              Cr√©ation de {numQuestions} questions depuis votre cours
            </p>
            <div className="mt-6 flex justify-center space-x-2">
              <div className="w-3 h-3 bg-blue-600 rounded-full animate-bounce"></div>
              <div className="w-3 h-3 bg-blue-600 rounded-full animate-bounce" style={{ animationDelay: '0.1s' }}></div>
              <div className="w-3 h-3 bg-blue-600 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
            </div>
          </div>
        )}

        {step === 'taking' && quiz && (
          <QuizDisplay quiz={quiz} onComplete={handleQuizCompleted} />
        )}

        {step === 'results' && quiz && (
          <QuizResults
            quiz={quiz}
            userAnswers={userAnswers}
            onRetake={handleRetake}
            onNewQuiz={handleNewQuiz}
          />
        )}
      </div>
    </div>
  );
}


////////////////////////////////////////////////////////////////////////////////
FICHIER: app/workspace/courses/[id]/page.tsx
////////////////////////////////////////////////////////////////////////////////
'use client';

import { useEffect, useState } from 'react';
import { useParams, useRouter } from 'next/navigation';
import { useUser } from '@clerk/nextjs';
import { getCourseById, updateCourse, Course } from '@/lib/courseService';
import { getCourseFlashcardDecks } from '@/lib/flashcardService';
import { supabase } from '@/lib/supabase';
import { ArrowLeft, Loader2, Calendar, Edit2, Check, X, Copy, Download } from 'lucide-react';
import CourseActions from '@/components/workspace/CourseActions';

export default function CourseDetailPage() {
  const params = useParams();
  const router = useRouter();
  const { user, isLoaded } = useUser();
  const [course, setCourse] = useState<Course | null>(null);
  const [loading, setLoading] = useState(true);
  const [editing, setEditing] = useState(false);
  const [editedTitle, setEditedTitle] = useState('');
  const [editedDescription, setEditedDescription] = useState('');
  const [copied, setCopied] = useState(false);
  const [quizCount, setQuizCount] = useState(0);
  const [flashcardCount, setFlashcardCount] = useState(0);

  useEffect(() => {
    if (isLoaded && user && params.id) {
      loadCourse();
      loadStats();
    }
  }, [isLoaded, user, params.id]);

  const loadCourse = async () => {
    if (!user) return;

    try {
      const data = await getCourseById(Number(params.id), user.id);
      if (!data) {
        router.push('/workspace/courses');
        return;
      }
      setCourse(data);
      setEditedTitle(data.title);
      setEditedDescription(data.description || '');
    } catch (err) {
      console.error('Erreur:', err);
      router.push('/workspace/courses');
    } finally {
      setLoading(false);
    }
  };

  const loadStats = async () => {
    if (!user) return;

    try {
      // Compter les quiz li√©s √† ce cours
      const { count: quizCountResult } = await supabase
        .from('quiz_history')
        .select('*', { count: 'exact', head: true })
        .eq('user_id', user.id);

      setQuizCount(quizCountResult || 0);

      // Compter les flashcard decks
      const flashcardDecks = await getCourseFlashcardDecks(user.id, Number(params.id));
      setFlashcardCount(flashcardDecks.length);

    } catch (err) {
      console.error('Erreur chargement stats:', err);
    }
  };

  const handleSaveEdit = async () => {
    if (!user || !course) return;

    try {
      await updateCourse(course.id, user.id, {
        title: editedTitle,
        description: editedDescription
      });
      setCourse({ ...course, title: editedTitle, description: editedDescription });
      setEditing(false);
    } catch (err: any) {
      alert(`Erreur: ${err.message}`);
    }
  };

  const handleCopyText = () => {
    if (!course) return;
    navigator.clipboard.writeText(course.extracted_text);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const handleDownloadText = () => {
    if (!course) return;
    const blob = new Blob([course.extracted_text], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${course.title}.txt`;
    a.click();
    URL.revokeObjectURL(url);
  };

  if (!isLoaded || loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50">
        <Loader2 className="animate-spin h-12 w-12 text-blue-600" />
      </div>
    );
  }

  if (!course) return null;

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50 py-12 px-4">
      <div className="max-w-5xl mx-auto">
        {/* Header */}
        <button
          onClick={() => router.push('/workspace/courses')}
          className="flex items-center text-gray-600 hover:text-gray-900 mb-6 transition-colors"
        >
          <ArrowLeft size={20} className="mr-2" />
          Retour aux cours
        </button>

        {/* Course Info Card */}
        <div className="bg-white rounded-2xl shadow-xl overflow-hidden mb-6">
          {/* Title Section */}
          <div className="p-8 border-b border-gray-200">
            {editing ? (
              <div className="space-y-4">
                <input
                  type="text"
                  value={editedTitle}
                  onChange={(e) => setEditedTitle(e.target.value)}
                  className="w-full text-3xl font-bold text-gray-900 border-2 border-blue-500 rounded-lg px-4 py-2 focus:outline-none"
                  placeholder="Titre du cours"
                />
                <textarea
                  value={editedDescription}
                  onChange={(e) => setEditedDescription(e.target.value)}
                  className="w-full text-gray-600 border-2 border-blue-500 rounded-lg px-4 py-2 focus:outline-none resize-none"
                  rows={3}
                  placeholder="Description (optionnel)"
                />
                <div className="flex gap-3">
                  <button
                    onClick={handleSaveEdit}
                    className="flex items-center space-x-2 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-all"
                  >
                    <Check size={18} />
                    <span>Sauvegarder</span>
                  </button>
                  <button
                    onClick={() => {
                      setEditing(false);
                      setEditedTitle(course.title);
                      setEditedDescription(course.description || '');
                    }}
                    className="flex items-center space-x-2 px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-all"
                  >
                    <X size={18} />
                    <span>Annuler</span>
                  </button>
                </div>
              </div>
            ) : (
              <div>
                <div className="flex items-start justify-between mb-4">
                  <h1 className="text-3xl font-bold text-gray-900">{course.title}</h1>
                  <button
                    onClick={() => setEditing(true)}
                    className="p-2 text-gray-600 hover:text-blue-600 hover:bg-blue-50 rounded-lg transition-all"
                  >
                    <Edit2 size={20} />
                  </button>
                </div>
                {course.description && (
                  <p className="text-gray-600 mb-4">{course.description}</p>
                )}
                <div className="flex items-center text-sm text-gray-500">
                  <Calendar size={16} className="mr-2" />
                  {new Date(course.created_at).toLocaleDateString('fr-FR', {
                    day: 'numeric',
                    month: 'long',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                  })}
                </div>
              </div>
            )}
          </div>

          {/* Course Actions */}
          <div className="p-8 bg-gray-50 border-b border-gray-200">
            <CourseActions
              courseId={course.id}
              quizCount={quizCount}
              flashcardCount={flashcardCount}
            />
          </div>

          {/* Text Content */}
          <div className="p-8">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-xl font-bold text-gray-900">üìù Texte Extrait</h2>
              <div className="flex gap-2">
                <button
                  onClick={handleCopyText}
                  className="flex items-center space-x-2 px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-all"
                >
                  <Copy size={18} />
                  <span>{copied ? 'Copi√© !' : 'Copier'}</span>
                </button>
                <button
                  onClick={handleDownloadText}
                  className="flex items-center space-x-2 px-4 py-2 bg-blue-100 text-blue-700 rounded-lg hover:bg-blue-200 transition-all"
                >
                  <Download size={18} />
                  <span>T√©l√©charger</span>
                </button>
              </div>
            </div>

            <div className="bg-gray-50 rounded-xl p-6 border border-gray-200 max-h-[400px] overflow-y-auto">
              <pre className="whitespace-pre-wrap font-mono text-sm text-gray-800 leading-relaxed">
                {course.extracted_text}
              </pre>
            </div>

            <div className="mt-4 text-sm text-gray-500 flex items-center justify-between">
              <span>{course.extracted_text.length} caract√®res</span>
              <span>{course.extracted_text.split(/\s+/).length} mots</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
