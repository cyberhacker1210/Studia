PARTIE 28 (FIN)

========================================
FICHIER : frontend/lib/pwaService.ts
========================================
export class PWAService {
  private static db: IDBDatabase | null = null;

  static async init() {
    if ('serviceWorker' in navigator) {
      try {
        const registration = await navigator.serviceWorker.register('/sw.js');
        console.log('✅ Service Worker enregistré:', registration);

        // Listen for updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker?.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              // New version available
              if (confirm('Nouvelle version disponible ! Recharger ?')) {
                window.location.reload();
              }
            }
          });
        });

        // Background sync
        if ('sync' in registration) {
          console.log('✅ Background Sync supporté');
        }

        // Push notifications
        if ('pushManager' in registration) {
          console.log('✅ Push Notifications supportées');
        }

      } catch (error) {
        console.error('❌ Erreur Service Worker:', error);
      }
    }

    // Init IndexedDB
    await this.initDB();
  }

  static async initDB(): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('StudiaDB', 1);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;

        // Store for offline courses
        if (!db.objectStoreNames.contains('courses')) {
          const courseStore = db.createObjectStore('courses', { keyPath: 'id' });
          courseStore.createIndex('user_id', 'user_id', { unique: false });
        }

        // Store for offline flashcards
        if (!db.objectStoreNames.contains('flashcards')) {
          const flashcardStore = db.createObjectStore('flashcards', { keyPath: 'id' });
          flashcardStore.createIndex('user_id', 'user_id', { unique: false });
        }

        // Store for pending actions (sync queue)
        if (!db.objectStoreNames.contains('pendingActions')) {
          db.createObjectStore('pendingActions', { keyPath: 'id', autoIncrement: true });
        }
      };
    });
  }

  static async saveCourseOffline(course: any) {
    if (!this.db) await this.initDB();

    return new Promise((resolve, reject) => {
      const tx = this.db!.transaction('courses', 'readwrite');
      const store = tx.objectStore('courses');
      const request = store.put(course);

      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  static async getCourseOffline(id: number) {
    if (!this.db) await this.initDB();

    return new Promise((resolve, reject) => {
      const tx = this.db!.transaction('courses', 'readonly');
      const store = tx.objectStore('courses');
      const request = store.get(id);

      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  static async getCoursesOffline(userId: string) {
    if (!this.db) await this.initDB();

    return new Promise<any[]>((resolve, reject) => {
      const tx = this.db!.transaction('courses', 'readonly');
      const store = tx.objectStore('courses');
      const index = store.index('user_id');
      const request = index.getAll(userId);

      request.onsuccess = () => resolve(request.result || []);
      request.onerror = () => reject(request.error);
    });
  }

  static async addPendingAction(action: any) {
    if (!this.db) await this.initDB();

    return new Promise((resolve, reject) => {
      const tx = this.db!.transaction('pendingActions', 'readwrite');
      const store = tx.objectStore('pendingActions');
      const request = store.add(action);

      request.onsuccess = () => {
        // Try to sync immediately
        if ('serviceWorker' in navigator && 'sync' in ServiceWorkerRegistration.prototype) {
          navigator.serviceWorker.ready.then((registration) => {
            return (registration as any).sync.register('sync-data');
          });
        }
        resolve(request.result);
      };
      request.onerror = () => reject(request.error);
    });
  }

  static isOnline(): boolean {
    return navigator.onLine;
  }

  static async getInstallPrompt() {
    let deferredPrompt: any;

    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
    });

    return deferredPrompt;
  }

  static async showInstallPrompt() {
    const deferredPrompt = await this.getInstallPrompt();

    if (deferredPrompt) {
      deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;
      console.log(`User response: ${outcome}`);
      return outcome === 'accepted';
    }

    return false;
  }
}

========================================
FICHIER : backend/src/studia/quiz.json
========================================

[
    {
        "question": "Quelle est la formule de la production selon le cours?",
        "answer": "Production = Travail humain + Machines + Matériel permanent (capital)"
    },
    {
        "question": "Quel organisme est représenté par l'acronyme Insee?",
        "answer": "Institut national de la statistique et des études économiques"
    },
    {
        "question": "Comment doit-on considérer la production selon le cours?",
        "answer": "Comme une activité socialement organisée visant à créer des biens et des services."
    },
    {
        "question": "Qu'est-ce qu'un modèle dans le contexte du cours?",
        "answer": "Une représentation simplifiée de la réalité, qui ne retient que quelques éléments frais d’algorithmes de causalité entre eux."
    },
    {
        "question": "Quels sont les trois éléments composant le schéma de la production dans le cours?",
        "answer": "Production, Consommation, Repartition des ressources"
    },
    {
        "question": "Comment définit-on un bien?",
        "answer": "Un produit matériel résultant de la production."
    },
    {
        "question": "Comment définit-on un service?",
        "answer": "Un produit immatériel résultant de la production."
    },
    {
        "question": "Quels sont les deux types de production mentionnés dans le cours?",
        "answer": "Marchande et Non marchande."
    },
    {
        "question": "Qu'est-ce que la production marchande?",
        "answer": "La production proposée et vendue sur le marché en une qui couvre au moins les coûts de production."
    },
    {
        "question": "Qu'est-ce que la production non marchande?",
        "answer": "La production non marchande correspond aux services offerts gratuitement ou pour gratuitement par les administrations publiques."
    }
]


========================================
FICHIER : venv_studia/lib/python3.13/site-packages/pip-24.3.1.dist-info/direct_url.json
========================================
{"archive_info": {"hash": "sha256=3790624780082365f47549d032f3770eeb2b1e8bd1f7b2e02dace1afa361b4ed", "hashes": {"sha256": "3790624780082365f47549d032f3770eeb2b1e8bd1f7b2e02dace1afa361b4ed"}}, "url": "file:///Applications/PyCharm.app/Contents/plugins/python-ce/helpers/pip-24.3.1-py2.py3-none-any.whl"}

========================================
FICHIER : venv_studia/lib/python3.13/site-packages/urllib3/contrib/emscripten/emscripten_fetch_worker.js
========================================
let Status = {
  SUCCESS_HEADER: -1,
  SUCCESS_EOF: -2,
  ERROR_TIMEOUT: -3,
  ERROR_EXCEPTION: -4,
};

let connections = {};
let nextConnectionID = 1;
const encoder = new TextEncoder();

self.addEventListener("message", async function (event) {
  if (event.data.close) {
    let connectionID = event.data.close;
    delete connections[connectionID];
    return;
  } else if (event.data.getMore) {
    let connectionID = event.data.getMore;
    let { curOffset, value, reader, intBuffer, byteBuffer } =
      connections[connectionID];
    // if we still have some in buffer, then just send it back straight away
    if (!value || curOffset >= value.length) {
      // read another buffer if required
      try {
        let readResponse = await reader.read();

        if (readResponse.done) {
          // read everything - clear connection and return
          delete connections[connectionID];
          Atomics.store(intBuffer, 0, Status.SUCCESS_EOF);
          Atomics.notify(intBuffer, 0);
          // finished reading successfully
          // return from event handler
          return;
        }
        curOffset = 0;
        connections[connectionID].value = readResponse.value;
        value = readResponse.value;
      } catch (error) {
        console.log("Request exception:", error);
        let errorBytes = encoder.encode(error.message);
        let written = errorBytes.length;
        byteBuffer.set(errorBytes);
        intBuffer[1] = written;
        Atomics.store(intBuffer, 0, Status.ERROR_EXCEPTION);
        Atomics.notify(intBuffer, 0);
      }
    }

    // send as much buffer as we can
    let curLen = value.length - curOffset;
    if (curLen > byteBuffer.length) {
      curLen = byteBuffer.length;
    }
    byteBuffer.set(value.subarray(curOffset, curOffset + curLen), 0);

    Atomics.store(intBuffer, 0, curLen); // store current length in bytes
    Atomics.notify(intBuffer, 0);
    curOffset += curLen;
    connections[connectionID].curOffset = curOffset;

    return;
  } else {
    // start fetch
    let connectionID = nextConnectionID;
    nextConnectionID += 1;
    const intBuffer = new Int32Array(event.data.buffer);
    const byteBuffer = new Uint8Array(event.data.buffer, 8);
    try {
      const response = await fetch(event.data.url, event.data.fetchParams);
      // return the headers first via textencoder
      var headers = [];
      for (const pair of response.headers.entries()) {
        headers.push([pair[0], pair[1]]);
      }
      let headerObj = {
        headers: headers,
        status: response.status,
        connectionID,
      };
      const headerText = JSON.stringify(headerObj);
      let headerBytes = encoder.encode(headerText);
      let written = headerBytes.length;
      byteBuffer.set(headerBytes);
      intBuffer[1] = written;
      // make a connection
      connections[connectionID] = {
        reader: response.body.getReader(),
        intBuffer: intBuffer,
        byteBuffer: byteBuffer,
        value: undefined,
        curOffset: 0,
      };
      // set header ready
      Atomics.store(intBuffer, 0, Status.SUCCESS_HEADER);
      Atomics.notify(intBuffer, 0);
      // all fetching after this goes through a new postmessage call with getMore
      // this allows for parallel requests
    } catch (error) {
      console.log("Request exception:", error);
      let errorBytes = encoder.encode(error.message);
      let written = errorBytes.length;
      byteBuffer.set(errorBytes);
      intBuffer[1] = written;
      Atomics.store(intBuffer, 0, Status.ERROR_EXCEPTION);
      Atomics.notify(intBuffer, 0);
    }
  }
});
self.postMessage({ inited: true });

